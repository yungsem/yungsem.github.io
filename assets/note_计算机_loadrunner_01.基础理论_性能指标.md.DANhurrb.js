import{_ as a,c as e,o as t,a4 as r}from"./chunks/framework.4aTu-Nia.js";const o="/assets/user-load-throughput.drawio.Ba72JUkJ.png",b=JSON.parse('{"title":"性能指标","description":"","frontmatter":{},"headers":[],"relativePath":"note/计算机/loadrunner/01.基础理论/性能指标.md","filePath":"note/计算机/loadrunner/01.基础理论/性能指标.md"}'),l={name:"note/计算机/loadrunner/01.基础理论/性能指标.md"},i=r('<h1 id="性能指标" tabindex="-1">性能指标 <a class="header-anchor" href="#性能指标" aria-label="Permalink to &quot;性能指标&quot;">​</a></h1><h2 id="并发数" tabindex="-1">并发数 <a class="header-anchor" href="#并发数" aria-label="Permalink to &quot;并发数&quot;">​</a></h2><ul><li>系统用户数：系统注册的总用户数。</li><li>在线用户数：某一时刻同时在线的用户数量，这些用户不一定同时请求系统的某一个资源。</li><li>并发用户数：某一时刻同时请求系统某一资源的用户数量，在 LoadRunner 中可以近似理解为 vuser ，在 Jemeter 中可以近似理解为线程数。</li></ul><blockquote><p>系统用户数 &gt;= 在线用户数 &gt;= 并发用户数</p></blockquote><h2 id="响应时间" tabindex="-1">响应时间 <a class="header-anchor" href="#响应时间" aria-label="Permalink to &quot;响应时间&quot;">​</a></h2><p>响应时间 = 网络传输时间（请求+返回） + 服务器处理（一层或多层）</p><h2 id="吞吐量" tabindex="-1">吞吐量 <a class="header-anchor" href="#吞吐量" aria-label="Permalink to &quot;吞吐量&quot;">​</a></h2><p>系统在单位时间内能处理的请求数，单位：请求数/秒。</p><p><img src="'+o+'" alt=""></p><p>吞吐量达到饱和，意味着系统的一种或多种资源达到饱和。</p><h2 id="资源利用率" tabindex="-1">资源利用率 <a class="header-anchor" href="#资源利用率" aria-label="Permalink to &quot;资源利用率&quot;">​</a></h2><ul><li>CPU</li><li>内存</li><li>磁盘IO</li><li>网络IO</li><li>网络带宽</li></ul><h2 id="tps" tabindex="-1">TPS <a class="header-anchor" href="#tps" aria-label="Permalink to &quot;TPS&quot;">​</a></h2><p>每秒通过事务数。通常和平均事务响应时间结合分析系统性能。</p>',14),n=[i];function s(h,d,c,_,u,p){return t(),e("div",null,n)}const f=a(l,[["render",s]]);export{b as __pageData,f as default};
