import{_ as e,c as t,o,a4 as s}from"./chunks/framework.4aTu-Nia.js";const g=JSON.parse('{"title":"网络抓包","description":"","frontmatter":{},"headers":[],"relativePath":"note/计算机/linux-ops/01.网络设置/网络抓包.md","filePath":"note/计算机/linux-ops/01.网络设置/网络抓包.md"}'),p={name:"note/计算机/linux-ops/01.网络设置/网络抓包.md"},n=s('<h1 id="网络抓包" tabindex="-1">网络抓包 <a class="header-anchor" href="#网络抓包" aria-label="Permalink to &quot;网络抓包&quot;">​</a></h1><h2 id="tcpdump-命令" tabindex="-1">tcpdump 命令 <a class="header-anchor" href="#tcpdump-命令" aria-label="Permalink to &quot;tcpdump 命令&quot;">​</a></h2><div class="language-ssh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ssh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>tcpdump -p -i eth0 -nn -s0 -v port 502 -w modbus.pcap</span></span></code></pre></div><ul><li><p><strong>-i</strong> : 选择要捕获的接口，通常是以太网卡或无线网卡。</p></li><li><p><strong>-nn</strong> : 单个 n 表示不解析域名，直接显示 IP；两个 n 表示不解析域名和端口。这样不仅方便查看 IP 和端口号，而且在抓取大量数据时非常高效，因为域名解析会降低抓取速度。</p></li><li><p><strong>-s0</strong> : tcpdump 默认只会截取前 <code>96</code> 字节的内容，要想截取所有的报文内容，可以使用 <code>-s number</code>， <code>number</code> 就是你要截取的报文字节数，如果是 0 的话，表示截取报文全部内容。</p></li><li><p><strong>-v</strong> : 使用 <code>-v</code>，<code>-vv</code> 和 <code>-vvv</code> 来显示更多的详细信息，通常会显示更多与特定协议相关的信息。</p></li><li><p><strong>port</strong> : 这是一个常见的端口过滤器，表示仅抓取 <code>80</code> 端口上的流量，通常是 HTTP。</p></li><li><p><strong>-p</strong> : 不让网络接口进入混杂模式。默认情况下使用 tcpdump 抓包时，会让网络接口进入混杂模式。一般计算机网卡都工作在非混杂模式下，此时网卡只接受来自网络端口的目的地址指向自己的数据。当网卡工作在混杂模式下时，网卡将来自接口的所有数据都捕获并交给相应的驱动程序。如果设备接入的交换机开启了混杂模式，使用 <code>-p</code> 选项可以有效地过滤噪声。</p></li><li><p><strong>-e</strong> : 显示数据链路层信息。默认情况下 tcpdump 不会显示数据链路层信息，使用 <code>-e</code> 选项可以显示源和目的 MAC 地址，以及 VLAN tag 信息。例如：</p></li><li><p><strong>-w</strong> : 选项用来把数据报文输出到文件</p></li></ul>',4),a=[n];function c(d,i,r,l,_,u){return o(),t("div",null,a)}const m=e(p,[["render",c]]);export{g as __pageData,m as default};
